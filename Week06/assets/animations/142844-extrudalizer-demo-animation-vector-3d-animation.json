{"v":"5.10.2","fr":30,"ip":0,"op":1800,"w":1000,"h":1000,"nm":"Comp 10","ddd":0,"assets":[],"fonts":{"list":[{"origin":0,"fPath":"","fClass":"","fFamily":"Helvetica","fWeight":"","fStyle":"Regular","fName":"Helvetica","ascent":71.9094140622765}]},"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"octagon_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[488,486.987,0],"ix":2,"l":2},"a":{"a":0,"k":[-12,-13.013,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":76,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":75,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[-188,145,-137.5],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":65,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":0,"k":0,"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":0,"k":0,"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-60]},{"t":300,"s":[300]}],"ix":14,"x":"var $bm_rt;\n$bm_rt = loopOut();"}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[230]},{"t":600,"s":[-490]}],"ix":15,"x":"var $bm_rt;\n$bm_rt = loopOut();"}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[95]},{"t":900,"s":[-265]}],"ix":16,"x":"var $bm_rt;\n$bm_rt = loopOut();"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.898338913918,0.02680003643,1,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0.5,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":80,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0,1,1,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0,1,1,1],"ix":32,"x":"var $bm_rt;\nvar r, g, b;\nr = thisComp.layer('octagon_1').effect('R 2')('Slider');\ng = thisComp.layer('octagon_1').effect('G 2')('Slider');\nb = thisComp.layer('octagon_1').effect('B 2')('Slider');\n$bm_rt = [\n    r,\n    g,\n    b,\n    1\n];"}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46,"x":"var $bm_rt;\nvar r, g, b;\nr = thisComp.layer('octagon_1').effect('R 2')('Slider');\ng = thisComp.layer('octagon_1').effect('G 2')('Slider');\nb = thisComp.layer('octagon_1').effect('B 2')('Slider');\n$bm_rt = [\n    r,\n    g,\n    b,\n    1\n];"}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":7,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":100,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":0,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var left_top = [\n        front_bb[0],\n        front_bb[1]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var right_top = [\n        front_bb[2],\n        front_bb[3]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var left_bottom = [\n        front_bb[4],\n        front_bb[5]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var right_bottom = [\n        front_bb[6],\n        front_bb[7]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":0,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var left_top = [\n        back_bb[0],\n        back_bb[1]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var right_top = [\n        back_bb[2],\n        back_bb[3]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var left_bottom = [\n        back_bb[4],\n        back_bb[5]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var right_bottom = [\n        back_bb[6],\n        back_bb[7]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0},{"ty":6,"nm":"","mn":"Pseudo/Extrudalizer-0069","ix":69,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0070","ix":70,"v":0},{"ty":6,"nm":"Extrudalizer v 1.00","mn":"Pseudo/Extrudalizer-0071","ix":71,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0072","ix":72,"v":0},{"ty":6,"nm":"(c) 2023 IVG Design","mn":"Pseudo/Extrudalizer-0073","ix":73,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0074","ix":74,"v":0}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[0,-150],[106.066,-106.066],[150,0],[106.066,106.066],[0,150],[-106.066,106.066],[-150,0],[-106.066,-106.066]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Polystar 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[10,10],"ix":2},"p":{"a":0,"k":[0,0],"ix":3,"x":"var $bm_rt;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';')[5];\nvar point = arr_as_str.split(',').map(s => parseFloat(s));\n$bm_rt = point;"},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isHidden = effect('Extrudalizer')('Hide anchor point').value;\n$bm_rt = $bm_mul(!isHidden, 100);"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ANCHOR POINT","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar points__3D = [];\nvar ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = ret_arr.length / 3; i < il; i++) {\n    points__3D.push(ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points__2D = points__3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar num_pts = points__2D.length;\nvar targetPathIsClosed = arr_as_str[3] === 'true';\n$bm_rt = createPath(points__2D, Array(num_pts).fill([\n    0,\n    0\n]), Array(num_pts).fill([\n    0,\n    0\n]), targetPathIsClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Front color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Front opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar is_facing_towards_us = data.split(';')[4].split('/')[0] === 'true';\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":true},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar points__3D = [];\nvar ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = ret_arr.length / 3; i < il; i++) {\n    points__3D.push(ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points__2D = points__3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar num_pts = points__2D.length;\nvar targetPathIsClosed = arr_as_str[3] === 'true';\n$bm_rt = createPath(points__2D, Array(num_pts).fill([\n    0,\n    0\n]), Array(num_pts).fill([\n    0,\n    0\n]), targetPathIsClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Back color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Back opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 0;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 0 - 1';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 0;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 0;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 1;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 1 - 2';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 1;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 1;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 2;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 2 - 3';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 2;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 2;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 2 - 3","np":4,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 3;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 3 - 4';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 3;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 3;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 3 - 4","np":4,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 4;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 4 - 5';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 4;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 4;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 4 - 5","np":4,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 5;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 5 - 6';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 5;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 5;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 5 - 6","np":4,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 6;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 6 - 7';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 6;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 6;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 6 - 7","np":4,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 7;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 7 - 0';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 7;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 7;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 7 - 0","np":4,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":8,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":1812,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":5,"nm":"EXTR DATA octagon_2","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[500,500,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":118,"f":"Helvetica","t":"","ca":0,"j":0,"tr":52,"lh":152,"ls":109,"fc":[1,0.845,0.233],"sc":[0,0,0],"sw":0.00999999977648,"of":false},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal, get2D_projection, getSpPoint2D, getBoundingBox, getModelMatrix, getModelMatrix2, transformPoint, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrices, multiplyArrayOfMatrices, getTranslate, getTranslate2D, getPoint, getArea, isClockwise, getCenter, hasNoneZeroValues, getDistance, angle_between, isStraightLine_w_delta, isFacingTowardsUs, compare_sides;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\ngetNormal = function (pts) {\n    var dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    return dir;\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetSpPoint2D = function (a, b, c) {\n    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], x3 = c[0], y3 = c[1];\n    var px = $bm_sub(x2, x1), py = $bm_sub(y2, y1);\n    var dAB = $bm_sum($bm_mul(px, px), $bm_mul(py, py));\n    var t = $bm_div($bm_sum($bm_mul($bm_sub(x3, x1), px), $bm_mul($bm_sub(y3, y1), py)), dAB);\n    var x = $bm_sum(x1, $bm_mul(t, px)), y = $bm_sum(y1, $bm_mul(t, py));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = $bm_sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = $bm_sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        $bm_sum(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        $bm_sum(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetModelMatrix = function (posValue, angles) {\n    return multiplyArrayOfMatrices([\n        getPositionMatrix(posValue),\n        getRotationMatrix(angles)\n    ]);\n};\ngetModelMatrix2 = function (posValue, angles, origin) {\n    return multiplyArrayOfMatrices([\n        getPositionMatrix(posValue),\n        getPositionMatrix(origin.map(i => -i)),\n        getRotationMatrix(angles),\n        getPositionMatrix(origin)\n    ]);\n};\ntransformPoint = function (p, move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    if (p.length == 2) {\n        p = [\n            ...p,\n            0\n        ];\n    }\n    if (sc !== 1) {\n        p = getTranslate(multiplyArrayOfMatrices([\n            getPositionMatrix(p),\n            getPositionMatrix(pivot.map(i => -i)),\n            getScaleMatrix(sc),\n            getPositionMatrix(pivot)\n        ]));\n    }\n    if (pitch_angles !== [\n            0,\n            0,\n            0\n        ]) {\n        p = getTranslate(getModelMatrix2(add(p, move), pitch_angles, pivot));\n    }\n    if (orbit_angles !== [\n            0,\n            0,\n            0\n        ]) {\n        p = getTranslate(getModelMatrix2(sub(p, anch), orbit_angles, [\n            0,\n            0,\n            0\n        ]));\n    }\n    return p;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul($bm_neg(angleY), Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul($bm_neg(angleX), Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    var cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    var cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    var cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrices = function (a, b) {\n    var a11 = a[0], a12 = a[4], a13 = a[8], a14 = a[12];\n    var a21 = a[1], a22 = a[5], a23 = a[9], a24 = a[13];\n    var a31 = a[2], a32 = a[6], a33 = a[10], a34 = a[14];\n    var a41 = a[3], a42 = a[7], a43 = a[11], a44 = a[15];\n    var b11 = b[0], b12 = b[4], b13 = b[8], b14 = b[12];\n    var b21 = b[1], b22 = b[5], b23 = b[9], b24 = b[13];\n    var b31 = b[2], b32 = b[6], b33 = b[10], b34 = b[14];\n    var b41 = b[3], b42 = b[7], b43 = b[11], b44 = b[15];\n    var result = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    result[0] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b11), $bm_mul(a12, b21)), $bm_mul(a13, b31)), $bm_mul(a14, b41));\n    result[4] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b12), $bm_mul(a12, b22)), $bm_mul(a13, b32)), $bm_mul(a14, b42));\n    result[8] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b13), $bm_mul(a12, b23)), $bm_mul(a13, b33)), $bm_mul(a14, b43));\n    result[12] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b14), $bm_mul(a12, b24)), $bm_mul(a13, b34)), $bm_mul(a14, b44));\n    result[1] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b11), $bm_mul(a22, b21)), $bm_mul(a23, b31)), $bm_mul(a24, b41));\n    result[5] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b12), $bm_mul(a22, b22)), $bm_mul(a23, b32)), $bm_mul(a24, b42));\n    result[9] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b13), $bm_mul(a22, b23)), $bm_mul(a23, b33)), $bm_mul(a24, b43));\n    result[13] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b14), $bm_mul(a22, b24)), $bm_mul(a23, b34)), $bm_mul(a24, b44));\n    result[2] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b11), $bm_mul(a32, b21)), $bm_mul(a33, b31)), $bm_mul(a34, b41));\n    result[6] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b12), $bm_mul(a32, b22)), $bm_mul(a33, b32)), $bm_mul(a34, b42));\n    result[10] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b13), $bm_mul(a32, b23)), $bm_mul(a33, b33)), $bm_mul(a34, b43));\n    result[14] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b14), $bm_mul(a32, b24)), $bm_mul(a33, b34)), $bm_mul(a34, b44));\n    result[3] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b11), $bm_mul(a42, b21)), $bm_mul(a43, b31)), $bm_mul(a44, b41));\n    result[7] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b12), $bm_mul(a42, b22)), $bm_mul(a43, b32)), $bm_mul(a44, b42));\n    result[11] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b13), $bm_mul(a42, b23)), $bm_mul(a43, b33)), $bm_mul(a44, b43));\n    result[15] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b14), $bm_mul(a42, b24)), $bm_mul(a43, b34)), $bm_mul(a44, b44));\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ngetTranslate = function (matrix) {\n    return [\n        matrix[3],\n        matrix[7],\n        matrix[11]\n    ];\n};\ngetTranslate2D = function (matrix) {\n    return [\n        matrix[3],\n        matrix[7]\n    ];\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    var x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    var y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCenter = function (pts) {\n    var cp = [\n        0,\n        0\n    ];\n    var num_pts = pts.length;\n    for (var i = 0; i < num_pts; i++) {\n        cp = add(cp, pts[i]);\n    }\n    cp = div(cp, num_pts);\n    return cp;\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\ngetDistance = function (p1, p2) {\n    var distance, dx, dy;\n    dx = $bm_sub(p2[0], p1[0]);\n    dy = $bm_sub(p2[1], p1[1]);\n    distance = Math.sqrt($bm_sum($bm_mul(dx, dx), $bm_mul(dy, dy)));\n    return distance;\n};\nangle_between = function (a, b) {\n    var dot_prod = dot_(a, b);\n    var mag_a = len_vec(a);\n    var mag_b = len_vec(b);\n    var cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nconst shape_layer = thisComp.layer($bm_sub(index, 1));\nconst targetPath = shape_layer(2)(1)(2)(1)(2);\nconst targetPathIsClosed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nvar is_front_clockwise = isClockwise(pnts);\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    const subdivs = 5;\n    var pointsF = [], in_tangents = [], out_tangents = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        pointsF.push(pnts[i]);\n        in_tangents.push([\n            0,\n            0\n        ]);\n        out_tangents.push([\n            0,\n            0\n        ]);\n        if (len_vec(out1) !== 0 || len_vec(in2) !== 0) {\n            var a = len_vec(out1) === 0 ? sub(p2, p1) : out1;\n            var b = len_vec(in2) === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.98)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                    in_tangents.push([\n                        0,\n                        0\n                    ]);\n                    out_tangents.push([\n                        0,\n                        0\n                    ]);\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n    inTangents = in_tangents;\n    outTangents = out_tangents;\n}\nvar num_pts = pnts.length;\nvar zero_center_point = getCenter(pnts);\nvar zero_center_point_3D = [\n    ...zero_center_point,\n    0\n];\nvar z0_transformed = transformPoint([\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nvar z1_transformed = transformPoint([\n    0,\n    0,\n    1\n], [\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nvar front_facing_towards_us = isFacingTowardsUs(z0_transformed, z1_transformed);\nvar points_front_3D = pnts.map(pnt => transformPoint(pnt, [\n    0,\n    0,\n    depth / 2\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]));\nvar points_back_3D = pnts.map(pnt => transformPoint(pnt, [\n    0,\n    0,\n    -depth / 2\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]));\nvar winding_sides = [];\nvar sorted_sides = [];\nfor (var i = 0; i < num_pts; i++) {\n    if (!targetPathIsClosed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    var side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ]);\n    if (!is_front_clockwise) {\n        var side_normal = mul(side_normal, -1);\n    }\n    winding_sides.push(isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], side_normal));\n    var side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts)\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    var s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nvar sorted_winding_sides = [];\nfor (var i = 0, il = sorted_sides.length; i < il; i++) {\n    sorted_winding_sides.push(winding_sides[sorted_sides[i][0]]);\n}\nvar n = sub(points_front_3D[0], points_back_3D[0]);\nvar bb_front_2D = [], bb_back_2D = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let bb_coords = [\n        bb.left_top,\n        bb.right_top,\n        bb.left_bottom\n    ];\n    if (use_bb_front) {\n        var bb_front_3D = bb_coords.map(pnt => transformPoint(pnt, [\n            0,\n            0,\n            depth / 2\n        ], scale_front, zero_center_point_3D, [\n            pivot_angleX,\n            pivot_angleY,\n            pivot_angleZ\n        ], anchor, [\n            angleX,\n            angleY,\n            angleZ\n        ]));\n        bb_front_2D = get2D_projection(bb_front_3D);\n        bb_front_2D.push(add(bb_front_2D[2], sub(bb_front_2D[1], bb_front_2D[0])));\n    }\n    if (use_bb_back) {\n        var bb_back_3D = bb_coords.map(pnt => transformPoint(pnt, [\n            0,\n            0,\n            -depth / 2\n        ], scale_back, zero_center_point_3D, [\n            pivot_angleX,\n            pivot_angleY,\n            pivot_angleZ\n        ], anchor, [\n            angleX,\n            angleY,\n            angleZ\n        ]));\n        bb_back_2D = get2D_projection(bb_back_3D);\n        bb_back_2D.push(add(bb_back_2D[2], sub(bb_back_2D[1], bb_back_2D[0])));\n    }\n}\nvar grad_property = null;\nfor (var i = 1, il = shape_layer(2)(1)(2).numProperties; i <= il; i++) {\n    if (shape_layer(2)(1)(2)(i)._name.match(/grad/gi)) {\n        grad_property = shape_layer(2)(1)(2)(i);\n        break;\n    }\n}\nif (grad_property != null) {\n    var grad_start = grad_property.startPoint.value;\n    var grad_end = grad_property.endPoint.value;\n    var grad_start_front = transformPoint(grad_start, [\n        0,\n        0,\n        $bm_div(depth, 2)\n    ], scale_front, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_end_front = transformPoint(grad_end, [\n        0,\n        0,\n        $bm_div(depth, 2)\n    ], scale_front, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_start_back = transformPoint(grad_start, [\n        0,\n        0,\n        $bm_div($bm_neg(depth), 2)\n    ], scale_back, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_end_back = transformPoint(grad_end, [\n        0,\n        0,\n        $bm_div($bm_neg(depth), 2)\n    ], scale_back, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_start_front_new = grad_start_front, grad_end_front_new = grad_end_front;\n    var grad_start_back_new = grad_start_back, grad_end_back_new = grad_end_back;\n    var grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    var grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if ([\n            grad_front_rot,\n            grad_back_rot\n        ] !== [\n            0,\n            0\n        ]) {\n        var grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        var grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        var grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        var grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        var grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        var grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            var cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            var cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nvar sep = ';', subsep = '/';\nvar txt = points_front_3D.toString();\ntxt = $bm_sum(txt, $bm_sum(sep, points_back_3D.toString()));\ntxt = $bm_sum(txt, $bm_sum(sep, sorted_sides.toString()));\ntxt = $bm_sum(txt, $bm_sum(sep, targetPathIsClosed.toString()));\ntxt = $bm_sum(txt, $bm_sum($bm_sum($bm_sum(sep, front_facing_towards_us.toString()), subsep), sorted_winding_sides.toString()));\ntxt = $bm_sum(txt, $bm_sum(sep, [\n    0,\n    0\n].toString()));\ntxt = $bm_sum(txt, $bm_sum($bm_sum(sep, n.toString()), subsep));\ntxt = $bm_sum(txt, $bm_sum($bm_sum(bb_front_2D, subsep), bb_back_2D));\nif (grad_property != null) {\n    txt = $bm_sum(txt, $bm_sum(sep, grad_start_front_new.toString()));\n    txt = $bm_sum(txt, $bm_sum(sep, grad_end_front_new.toString()));\n    txt = $bm_sum(txt, $bm_sum(sep, grad_start_back_new.toString()));\n    txt = $bm_sum(txt, $bm_sum(sep, grad_end_back_new.toString()));\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":1800,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"octagon_1","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-12,-13.013,0],"ix":2,"l":2},"a":{"a":0,"k":[-12,-13.013,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":76,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":200,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3,"x":"var $bm_rt;\nvar parentLayerPosition = thisComp.layer('octagon_2').effect('Extrudalizer')('Position');\nvar x = parentLayerPosition[0];\nvar y = parentLayerPosition[1];\nvar z = $bm_sum(parentLayerPosition[2], 137.5);\n$bm_rt = [\n    x,\n    y,\n    z\n];"}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":1,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('octagon_2').effect('Extrudalizer')('Pitch (x)');"}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('octagon_2').effect('Extrudalizer')('Yaw (y)');"}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":0,"k":45,"ix":11,"x":"var $bm_rt;\n$bm_rt = $bm_sum(thisComp.layer('octagon_2').effect('Extrudalizer')('Roll (z)'), 45);"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":-60,"ix":14,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('octagon_2').effect('Extrudalizer')('X Rotation');"}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":230,"ix":15,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('octagon_2').effect('Extrudalizer')('Y Rotation');"}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":95,"ix":16,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('octagon_2').effect('Extrudalizer')('Z Rotation');"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":1,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.876764297485,0.262159973383,0.990909814835,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":0.5,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":80,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0,1,1,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0,1,1,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points o","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0,1,1,1],"ix":46,"x":"var $bm_rt;\nvar r, g, b;\nr = effect('R')('Slider');\ng = effect('G')('Slider');\nb = effect('B')('Slider');\n$bm_rt = [\n    r,\n    g,\n    b,\n    1\n];"}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":81,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":25,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0.919920921326,0.08057256788,0.897057950497,1],"ix":51}},{"ty":7,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":100,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":0,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var left_top = [\n        front_bb[0],\n        front_bb[1]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var right_top = [\n        front_bb[2],\n        front_bb[3]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var left_bottom = [\n        front_bb[4],\n        front_bb[5]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var front_bb = data.split(sep)[6].split(subsep)[1].split(',').map(s => parseFloat(s));\n    var right_bottom = [\n        front_bb[6],\n        front_bb[7]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":0,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var left_top = [\n        back_bb[0],\n        back_bb[1]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var right_top = [\n        back_bb[2],\n        back_bb[3]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_top, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var left_bottom = [\n        back_bb[4],\n        back_bb[5]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(left_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\nvar use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var sep = ';', subsep = '/';\n    var back_bb = data.split(sep)[6].split(subsep)[2].split(',').map(s => parseFloat(s));\n    var right_bottom = [\n        back_bb[6],\n        back_bb[7]\n    ];\n    var w = $bm_div(thisComp.width, 2);\n    var h = $bm_div(thisComp.height, 2);\n    $bm_rt = add(right_bottom, [\n        w,\n        h\n    ]);\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0},{"ty":6,"nm":"","mn":"Pseudo/Extrudalizer-0069","ix":69,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0070","ix":70,"v":0},{"ty":6,"nm":"Extrudalizer v 1.00","mn":"Pseudo/Extrudalizer-0071","ix":71,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0072","ix":72,"v":0},{"ty":6,"nm":"(c) 2023 IVG Design","mn":"Pseudo/Extrudalizer-0073","ix":73,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0074","ix":74,"v":0}]},{"ty":5,"nm":"R","np":3,"mn":"ADBE Slider Control","ix":2,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":-332,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0.33]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":674,"s":[1]},{"t":1799,"s":[0.33]}],"ix":1,"x":"var $bm_rt;\n$bm_rt = loopOut('pingpong');"}}]},{"ty":5,"nm":"G","np":3,"mn":"ADBE Slider Control","ix":3,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":-62,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0.049]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":1215,"s":[1]},{"t":1799,"s":[0.049]}],"ix":1,"x":"var $bm_rt;\n$bm_rt = loopOut('pingpong');"}}]},{"ty":5,"nm":"B","np":3,"mn":"ADBE Slider Control","ix":4,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":-153,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0.264]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":427,"s":[1]},{"t":1799,"s":[0.264]}],"ix":1,"x":"var $bm_rt;\n$bm_rt = loopOut('pingpong');"}}]},{"ty":5,"nm":"R 2","np":3,"mn":"ADBE Slider Control","ix":5,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":-592,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0.471]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":666,"s":[1]},{"t":1799,"s":[0.471]}],"ix":1,"x":"var $bm_rt;\n$bm_rt = loopOut('pingpong');"}}]},{"ty":5,"nm":"G 2","np":3,"mn":"ADBE Slider Control","ix":6,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":-62,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0.225]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":214,"s":[1]},{"t":1799,"s":[0.225]}],"ix":1,"x":"var $bm_rt;\n$bm_rt = loopOut('pingpong');"}}]},{"ty":5,"nm":"B 2","np":3,"mn":"ADBE Slider Control","ix":7,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":-153,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0.151]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":859,"s":[1]},{"t":1799,"s":[0.151]}],"ix":1,"x":"var $bm_rt;\n$bm_rt = loopOut('pingpong');"}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[0,-150],[106.066,-106.066],[150,0],[106.066,106.066],[0,150],[-106.066,106.066],[-150,0],[-106.066,-106.066]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Polystar 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[10,10],"ix":2},"p":{"a":0,"k":[0,0],"ix":3,"x":"var $bm_rt;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';')[5];\nvar point = arr_as_str.split(',').map(s => parseFloat(s));\n$bm_rt = point;"},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isHidden = effect('Extrudalizer')('Hide anchor point').value;\n$bm_rt = $bm_mul(!isHidden, 100);"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ANCHOR POINT","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar points__3D = [];\nvar ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = ret_arr.length / 3; i < il; i++) {\n    points__3D.push(ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points__2D = points__3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar num_pts = points__2D.length;\nvar targetPathIsClosed = arr_as_str[3] === 'true';\n$bm_rt = createPath(points__2D, Array(num_pts).fill([\n    0,\n    0\n]), Array(num_pts).fill([\n    0,\n    0\n]), targetPathIsClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Front color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Front opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar is_facing_towards_us = data.split(';')[4].split('/')[0] === 'true';\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar points__3D = [];\nvar ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = ret_arr.length / 3; i < il; i++) {\n    points__3D.push(ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points__2D = points__3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar num_pts = points__2D.length;\nvar targetPathIsClosed = arr_as_str[3] === 'true';\n$bm_rt = createPath(points__2D, Array(num_pts).fill([\n    0,\n    0\n]), Array(num_pts).fill([\n    0,\n    0\n]), targetPathIsClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":true},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Back color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Back opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":true},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 0;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 0 - 1';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 0;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 0;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 1;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 1 - 2';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 1;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 1;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 2;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 2 - 3';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 2;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 2;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 2 - 3","np":4,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 3;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 3 - 4';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 3;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 3;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 3 - 4","np":4,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 4;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 4 - 5';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 4;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 4;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 4 - 5","np":4,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 5;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 5 - 6';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 5;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 5;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 5 - 6","np":4,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 6;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 6 - 7';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 6;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 6;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 6 - 7","np":4,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nconst side_index = 7;\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar arr_as_str = data.split(';');\nvar sorted_indices = arr_as_str[2];\nsorted_indices = sorted_indices.split(',').map(p => parseInt(p));\nvar srt_ind = [];\nfor (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n    srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nvar points_back_3D = [], points_front_3D = [];\nvar front_ret_arr = arr_as_str[0].split(',').map(s => parseFloat(s));\nvar back_ret_arr = arr_as_str[1].split(',').map(s => parseFloat(s));\nfor (var i = 0, il = front_ret_arr.length / 3; i < il; i++) {\n    points_back_3D.push(back_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    points_front_3D.push(front_ret_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n}\nvar points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nvar points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke color').value;"},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Edge stroke width').value;"},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\n$bm_rt = effect('Extrudalizer')('Sides fill shadow color').value;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt($bm_sum($bm_sum($bm_mul(a[1], a[1]), $bm_mul(a[0], a[0])), $bm_mul(a[2], a[2])));\n};\ngetNormal = function (points) {\n    var dir = cross_vec(sub(points[1], points[0]), sub(points[2], points[0]));\n    return div(dir, len_vec(dir));\n};\nvar data = thisComp.layer(index + 1).text.sourceText;\nvar sep = ';', subsep = '/';\nvar n = data.split(sep)[6].split(subsep)[0].split(',').map(s => parseFloat(s));\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    var sidename = 'SIDE 7 - 0';\n    var sidepath = content('--- EXTRUDALIZER ---').content('SIDES');\n    if (sidename.match('p') != null) {\n        sidepath = sidepath.content(sidename.slice(0, -3));\n    }\n    sidepath = sidepath.content(sidename);\n    var points = sidepath.content('ADBE Vector Shape - Group').path.points();\n    var side_pts = [\n        [\n            ...points[0],\n            0\n        ],\n        [\n            ...points[1],\n            0\n        ],\n        sub([\n            ...points[0],\n            0\n        ], mul(n, depth))\n    ];\n    var nn = getNormal(side_pts);\n    $bm_rt = value = $bm_mul(side_shadow_opacity_max, $bm_sub(1, Math.abs(dot_(nn, [\n        0,\n        0,\n        1\n    ]))));\n}"},"r":1,"bm":0,"nm":"Shadow Fill","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4,"x":"var $bm_rt;\nlet color = effect('Extrudalizer')('Sides color').value;\ntry {\n    const side_index = 7;\n    const data = thisComp.layer(index + 1).text.sourceText;\n    const arr_as_str = data.split(';');\n    var sorted_indices = arr_as_str[2];\n    sorted_indices = sorted_indices.split(',').map(p => parseInt(p));\n    var srt_ind = [];\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    const currentIndex = srt_ind[side_index][0];\n    color = effect('FACE ' + currentIndex)('Color').value;\n} catch (e) {\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst opacity = effect('Extrudalizer')('Sides opacity').value;\n$bm_rt = $bm_mul(!isWireframe, opacity);"},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nvar opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    var data = thisComp.layer(index + 1).text.sourceText;\n    var arr_as_str = data.split(';');\n    var targetPathIsClosed = arr_as_str[3] === 'true';\n    if (!targetPathIsClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        var sorted_winding_sides = arr_as_str[4].split('/')[1].split(',').map(b => b === 'true');\n        const side_index = 7;\n        var side_facing_us = sorted_winding_sides[side_index];\n        $bm_rt = value = side_facing_us ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 7 - 0","np":4,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":8,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":1817,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":4,"ty":5,"nm":"EXTR DATA octagon_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[500,500,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":118,"f":"Helvetica","t":"","ca":0,"j":0,"tr":52,"lh":152,"ls":109,"fc":[1,0.845,0.233],"sc":[0,0,0],"sw":0.00999999977648,"of":false},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, getNormal, get2D_projection, getSpPoint2D, getBoundingBox, getModelMatrix, getModelMatrix2, transformPoint, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrices, multiplyArrayOfMatrices, getTranslate, getTranslate2D, getPoint, getArea, isClockwise, getCenter, hasNoneZeroValues, getDistance, angle_between, isStraightLine_w_delta, isFacingTowardsUs, compare_sides;\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\ngetNormal = function (pts) {\n    var dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    return dir;\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetSpPoint2D = function (a, b, c) {\n    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], x3 = c[0], y3 = c[1];\n    var px = $bm_sub(x2, x1), py = $bm_sub(y2, y1);\n    var dAB = $bm_sum($bm_mul(px, px), $bm_mul(py, py));\n    var t = $bm_div($bm_sum($bm_mul($bm_sub(x3, x1), px), $bm_mul($bm_sub(y3, y1), py)), dAB);\n    var x = $bm_sum(x1, $bm_mul(t, px)), y = $bm_sum(y1, $bm_mul(t, py));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = $bm_sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = $bm_sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        $bm_sum(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        $bm_sum(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetModelMatrix = function (posValue, angles) {\n    return multiplyArrayOfMatrices([\n        getPositionMatrix(posValue),\n        getRotationMatrix(angles)\n    ]);\n};\ngetModelMatrix2 = function (posValue, angles, origin) {\n    return multiplyArrayOfMatrices([\n        getPositionMatrix(posValue),\n        getPositionMatrix(origin.map(i => -i)),\n        getRotationMatrix(angles),\n        getPositionMatrix(origin)\n    ]);\n};\ntransformPoint = function (p, move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    if (p.length == 2) {\n        p = [\n            ...p,\n            0\n        ];\n    }\n    if (sc !== 1) {\n        p = getTranslate(multiplyArrayOfMatrices([\n            getPositionMatrix(p),\n            getPositionMatrix(pivot.map(i => -i)),\n            getScaleMatrix(sc),\n            getPositionMatrix(pivot)\n        ]));\n    }\n    if (pitch_angles !== [\n            0,\n            0,\n            0\n        ]) {\n        p = getTranslate(getModelMatrix2(add(p, move), pitch_angles, pivot));\n    }\n    if (orbit_angles !== [\n            0,\n            0,\n            0\n        ]) {\n        p = getTranslate(getModelMatrix2(sub(p, anch), orbit_angles, [\n            0,\n            0,\n            0\n        ]));\n    }\n    return p;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul($bm_neg(angleY), Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul($bm_neg(angleX), Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    var cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    var cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    var cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrices = function (a, b) {\n    var a11 = a[0], a12 = a[4], a13 = a[8], a14 = a[12];\n    var a21 = a[1], a22 = a[5], a23 = a[9], a24 = a[13];\n    var a31 = a[2], a32 = a[6], a33 = a[10], a34 = a[14];\n    var a41 = a[3], a42 = a[7], a43 = a[11], a44 = a[15];\n    var b11 = b[0], b12 = b[4], b13 = b[8], b14 = b[12];\n    var b21 = b[1], b22 = b[5], b23 = b[9], b24 = b[13];\n    var b31 = b[2], b32 = b[6], b33 = b[10], b34 = b[14];\n    var b41 = b[3], b42 = b[7], b43 = b[11], b44 = b[15];\n    var result = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    result[0] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b11), $bm_mul(a12, b21)), $bm_mul(a13, b31)), $bm_mul(a14, b41));\n    result[4] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b12), $bm_mul(a12, b22)), $bm_mul(a13, b32)), $bm_mul(a14, b42));\n    result[8] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b13), $bm_mul(a12, b23)), $bm_mul(a13, b33)), $bm_mul(a14, b43));\n    result[12] = $bm_sum($bm_sum($bm_sum($bm_mul(a11, b14), $bm_mul(a12, b24)), $bm_mul(a13, b34)), $bm_mul(a14, b44));\n    result[1] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b11), $bm_mul(a22, b21)), $bm_mul(a23, b31)), $bm_mul(a24, b41));\n    result[5] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b12), $bm_mul(a22, b22)), $bm_mul(a23, b32)), $bm_mul(a24, b42));\n    result[9] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b13), $bm_mul(a22, b23)), $bm_mul(a23, b33)), $bm_mul(a24, b43));\n    result[13] = $bm_sum($bm_sum($bm_sum($bm_mul(a21, b14), $bm_mul(a22, b24)), $bm_mul(a23, b34)), $bm_mul(a24, b44));\n    result[2] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b11), $bm_mul(a32, b21)), $bm_mul(a33, b31)), $bm_mul(a34, b41));\n    result[6] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b12), $bm_mul(a32, b22)), $bm_mul(a33, b32)), $bm_mul(a34, b42));\n    result[10] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b13), $bm_mul(a32, b23)), $bm_mul(a33, b33)), $bm_mul(a34, b43));\n    result[14] = $bm_sum($bm_sum($bm_sum($bm_mul(a31, b14), $bm_mul(a32, b24)), $bm_mul(a33, b34)), $bm_mul(a34, b44));\n    result[3] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b11), $bm_mul(a42, b21)), $bm_mul(a43, b31)), $bm_mul(a44, b41));\n    result[7] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b12), $bm_mul(a42, b22)), $bm_mul(a43, b32)), $bm_mul(a44, b42));\n    result[11] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b13), $bm_mul(a42, b23)), $bm_mul(a43, b33)), $bm_mul(a44, b43));\n    result[15] = $bm_sum($bm_sum($bm_sum($bm_mul(a41, b14), $bm_mul(a42, b24)), $bm_mul(a43, b34)), $bm_mul(a44, b44));\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ngetTranslate = function (matrix) {\n    return [\n        matrix[3],\n        matrix[7],\n        matrix[11]\n    ];\n};\ngetTranslate2D = function (matrix) {\n    return [\n        matrix[3],\n        matrix[7]\n    ];\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    var x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    var y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCenter = function (pts) {\n    var cp = [\n        0,\n        0\n    ];\n    var num_pts = pts.length;\n    for (var i = 0; i < num_pts; i++) {\n        cp = add(cp, pts[i]);\n    }\n    cp = div(cp, num_pts);\n    return cp;\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\ngetDistance = function (p1, p2) {\n    var distance, dx, dy;\n    dx = $bm_sub(p2[0], p1[0]);\n    dy = $bm_sub(p2[1], p1[1]);\n    distance = Math.sqrt($bm_sum($bm_mul(dx, dx), $bm_mul(dy, dy)));\n    return distance;\n};\nangle_between = function (a, b) {\n    var dot_prod = dot_(a, b);\n    var mag_a = len_vec(a);\n    var mag_b = len_vec(b);\n    var cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nconst shape_layer = thisComp.layer($bm_sub(index, 1));\nconst targetPath = shape_layer(2)(1)(2)(1)(2);\nconst targetPathIsClosed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nvar is_front_clockwise = isClockwise(pnts);\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    const subdivs = 5;\n    var pointsF = [], in_tangents = [], out_tangents = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        pointsF.push(pnts[i]);\n        in_tangents.push([\n            0,\n            0\n        ]);\n        out_tangents.push([\n            0,\n            0\n        ]);\n        if (len_vec(out1) !== 0 || len_vec(in2) !== 0) {\n            var a = len_vec(out1) === 0 ? sub(p2, p1) : out1;\n            var b = len_vec(in2) === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.98)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                    in_tangents.push([\n                        0,\n                        0\n                    ]);\n                    out_tangents.push([\n                        0,\n                        0\n                    ]);\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n    inTangents = in_tangents;\n    outTangents = out_tangents;\n}\nvar num_pts = pnts.length;\nvar zero_center_point = getCenter(pnts);\nvar zero_center_point_3D = [\n    ...zero_center_point,\n    0\n];\nvar z0_transformed = transformPoint([\n    0,\n    0,\n    0\n], [\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nvar z1_transformed = transformPoint([\n    0,\n    0,\n    1\n], [\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nvar front_facing_towards_us = isFacingTowardsUs(z0_transformed, z1_transformed);\nvar points_front_3D = pnts.map(pnt => transformPoint(pnt, [\n    0,\n    0,\n    depth / 2\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]));\nvar points_back_3D = pnts.map(pnt => transformPoint(pnt, [\n    0,\n    0,\n    -depth / 2\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]));\nvar winding_sides = [];\nvar sorted_sides = [];\nfor (var i = 0; i < num_pts; i++) {\n    if (!targetPathIsClosed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    var side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ]);\n    if (!is_front_clockwise) {\n        var side_normal = mul(side_normal, -1);\n    }\n    winding_sides.push(isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], side_normal));\n    var side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts)\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    var s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nvar sorted_winding_sides = [];\nfor (var i = 0, il = sorted_sides.length; i < il; i++) {\n    sorted_winding_sides.push(winding_sides[sorted_sides[i][0]]);\n}\nvar n = sub(points_front_3D[0], points_back_3D[0]);\nvar bb_front_2D = [], bb_back_2D = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let bb_coords = [\n        bb.left_top,\n        bb.right_top,\n        bb.left_bottom\n    ];\n    if (use_bb_front) {\n        var bb_front_3D = bb_coords.map(pnt => transformPoint(pnt, [\n            0,\n            0,\n            depth / 2\n        ], scale_front, zero_center_point_3D, [\n            pivot_angleX,\n            pivot_angleY,\n            pivot_angleZ\n        ], anchor, [\n            angleX,\n            angleY,\n            angleZ\n        ]));\n        bb_front_2D = get2D_projection(bb_front_3D);\n        bb_front_2D.push(add(bb_front_2D[2], sub(bb_front_2D[1], bb_front_2D[0])));\n    }\n    if (use_bb_back) {\n        var bb_back_3D = bb_coords.map(pnt => transformPoint(pnt, [\n            0,\n            0,\n            -depth / 2\n        ], scale_back, zero_center_point_3D, [\n            pivot_angleX,\n            pivot_angleY,\n            pivot_angleZ\n        ], anchor, [\n            angleX,\n            angleY,\n            angleZ\n        ]));\n        bb_back_2D = get2D_projection(bb_back_3D);\n        bb_back_2D.push(add(bb_back_2D[2], sub(bb_back_2D[1], bb_back_2D[0])));\n    }\n}\nvar grad_property = null;\nfor (var i = 1, il = shape_layer(2)(1)(2).numProperties; i <= il; i++) {\n    if (shape_layer(2)(1)(2)(i)._name.match(/grad/gi)) {\n        grad_property = shape_layer(2)(1)(2)(i);\n        break;\n    }\n}\nif (grad_property != null) {\n    var grad_start = grad_property.startPoint.value;\n    var grad_end = grad_property.endPoint.value;\n    var grad_start_front = transformPoint(grad_start, [\n        0,\n        0,\n        $bm_div(depth, 2)\n    ], scale_front, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_end_front = transformPoint(grad_end, [\n        0,\n        0,\n        $bm_div(depth, 2)\n    ], scale_front, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_start_back = transformPoint(grad_start, [\n        0,\n        0,\n        $bm_div($bm_neg(depth), 2)\n    ], scale_back, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_end_back = transformPoint(grad_end, [\n        0,\n        0,\n        $bm_div($bm_neg(depth), 2)\n    ], scale_back, zero_center_point_3D, [\n        pivot_angleX,\n        pivot_angleY,\n        pivot_angleZ\n    ], anchor, [\n        angleX,\n        angleY,\n        angleZ\n    ]);\n    var grad_start_front_new = grad_start_front, grad_end_front_new = grad_end_front;\n    var grad_start_back_new = grad_start_back, grad_end_back_new = grad_end_back;\n    var grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    var grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if ([\n            grad_front_rot,\n            grad_back_rot\n        ] !== [\n            0,\n            0\n        ]) {\n        var grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        var grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        var grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        var grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        var grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        var grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            var cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            var cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nvar sep = ';', subsep = '/';\nvar txt = points_front_3D.toString();\ntxt = $bm_sum(txt, $bm_sum(sep, points_back_3D.toString()));\ntxt = $bm_sum(txt, $bm_sum(sep, sorted_sides.toString()));\ntxt = $bm_sum(txt, $bm_sum(sep, targetPathIsClosed.toString()));\ntxt = $bm_sum(txt, $bm_sum($bm_sum($bm_sum(sep, front_facing_towards_us.toString()), subsep), sorted_winding_sides.toString()));\ntxt = $bm_sum(txt, $bm_sum(sep, [\n    0,\n    0\n].toString()));\ntxt = $bm_sum(txt, $bm_sum($bm_sum(sep, n.toString()), subsep));\ntxt = $bm_sum(txt, $bm_sum($bm_sum(bb_front_2D, subsep), bb_back_2D));\nif (grad_property != null) {\n    txt = $bm_sum(txt, $bm_sum(sep, grad_start_front_new.toString()));\n    txt = $bm_sum(txt, $bm_sum(sep, grad_end_front_new.toString()));\n    txt = $bm_sum(txt, $bm_sum(sep, grad_start_back_new.toString()));\n    txt = $bm_sum(txt, $bm_sum(sep, grad_end_back_new.toString()));\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":1800,"st":0,"ct":1,"bm":0}],"markers":[]}